@(
    models: List[casualteam.openapigenerator.Model],
    getModelType: (casualteam.openapigenerator.Model,Boolean) => String,
    getValidationCode: casualteam.openapigenerator.Model => String
)
import java.nio.charset.Charset

import akka.http.scaladsl.model.{RequestEntity, ResponseEntity}
import akka.stream.Materializer
import io.circe.syntax._
import io.circe.{Decoder, Encoder}

import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future}

trait ModelJsonEncode[A] { def encodeJson(a: A): Either[Error,ResponseEntity] }
object ModelJsonEncode {
  def apply[A](implicit sh: ModelJsonEncode[A]): ModelJsonEncode[A] = sh

  object ops {
    def encodeJson[A: ModelJsonEncode](a: A) = ModelJsonEncode[A].encodeJson(a)
    implicit class ModelJsonEncodeOps[A: ModelJsonEncode](a: A) {
      def encodeJson = ModelJsonEncode[A].encodeJson(a)
    }
  }
}

trait ModelJsonDecode[A] {
  def decodeJson(
    requestEntity: RequestEntity,
    requestTimeout: FiniteDuration,
    requestMaxBytes: Long,
    defaultCharset: Charset
  ): Future[Either[Error, A]]
}
object ModelJsonDecode {
  def apply[A](implicit sh: ModelJsonDecode[A]): ModelJsonDecode[A] = sh
  object ops {
    implicit class ModelJsonDecodeOps(a: akka.http.scaladsl.model.RequestEntity) {
      def decodeJson[A: ModelJsonDecode](
        timeout: FiniteDuration,
        maxBytes: Long,
        defaultCharset: Charset
      ) = ModelJsonDecode[A].decodeJson(a, timeout, maxBytes, defaultCharset)
    }
  }
}

trait ModelJson {

  private def validationEncoder[T](validate: T => Either[Error,T])(implicit d: Decoder[T]) =
    d.emap(value => validate(value).left.map(_.value))

  private def validationEncoderOption[T](validate: T => Either[Error, T])(implicit d: Decoder[Option[T]]) =
    d.emap(_.map(value => validate(value).left.map(_.value).map(Option(_))).getOrElse(Right(None)))

  @{models
    .collect {
      case m: casualteam.openapigenerator.Model.Object => handlers.json.txt.objectModel(m, getModelType, getValidationCode)
      case m: casualteam.openapigenerator.Model.TypedMap => handlers.json.txt.typedMapModel(m, getModelType(_, true))
    }
  }

  implicit def m@{scala.util.Random.alphanumeric.take(10).mkString}[T](implicit encoder:Encoder[T]) =
      new ModelJsonEncode[T]{
          override def encodeJson(a: T): Either[Error, ResponseEntity] = {
              Right(encoder(a).noSpaces)
          }
      }

  implicit def m@{scala.util.Random.alphanumeric.take(10).mkString}[T](implicit d:Decoder[T], ec: ExecutionContext, m: Materializer) =
    new ModelJsonDecode[T] {
        override def decodeJson(
            requestEntity: RequestEntity,
            timeout: FiniteDuration,
            maxBytes: Long,
            defaultCharset: Charset
        ): Future[Either[Error, T]] = {
            requestEntity.toStrict(timeout, maxBytes)
                .map(_.data.decodeString(requestEntity.contentType.charsetOption.map(_.nioCharset).getOrElse(defaultCharset)))
                .map(_.asJson.as[T].left.map(f => Error(f.message)))
        }
    }
}

object ModelJson extends ModelJson
@(
    operations: List[casualteam.openapigenerator.Operation],
    getOperationName: casualteam.openapigenerator.Operation => String,
    getResponseType: casualteam.openapigenerator.Response => String,
    getModelType: casualteam.openapigenerator.Model => String,
    getRequestBodyName: casualteam.openapigenerator.RequestBody => String,
    getRequestBodyType: casualteam.openapigenerator.RequestBody => String
 )

trait Operations {
    @for(operation <- operations) {
        def @getOperationName(operation) (in: Operations.@getOperationName(operation)Request): scala.concurrent.Future[Operations.@getOperationName(operation)Response]
    }
}

object Operations {
    @for(operation <- operations) {

        case class @getOperationName(operation)Request(
            @if(operation.requestBody.isDefined){
                `@getRequestBodyName(operation.requestBody.get)` : @getRequestBodyType(operation.requestBody.get)@if(operation.parameters.nonEmpty){,}
            }
            @for((p,i) <- operation.parameters.zipWithIndex) {
              `@{p.name}` : @getModelType(p.model) @if(i < operation.parameters.size -1){,}
            }
        )

        sealed trait @getOperationName(operation)Response{ def code:Int }
        object @getOperationName(operation)Response {
            @for((statusCode,response) <- operation.responses.iterator) {
                @if(scala.util.Try(Integer.decode(statusCode)).isSuccess){
                    case class `@statusCode` (body: @getResponseType(response) ) extends @getOperationName(operation)Response{ val code: Int = @statusCode }
                } else if(statusCode == "default"){
                    case class default (body: @getResponseType(response), code: Int ) extends @getOperationName(operation)Response
                } else {
                    case class `@statusCode` (body: @getResponseType(response), code: Int  ) extends @getOperationName(operation)Response
                }
            }
        }
    }
}
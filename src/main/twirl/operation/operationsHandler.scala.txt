@(
    operations: List[casualteam.openapigenerator.Operation],
    getOperationName: casualteam.openapigenerator.Operation => String,
    getActualResponse: casualteam.openapigenerator.Response => casualteam.openapigenerator.Response.BaseResponse,
    getModelType: (casualteam.openapigenerator.Model, Boolean) => String,
    getRequestBodyName: casualteam.openapigenerator.RequestBody => String,
    getRequestBodyType: casualteam.openapigenerator.RequestBody => String,
    getMediaTypeModelEncoder: casualteam.openapigenerator.MediaTypeModel => String,
    getMediaTypeModelDecoder: (casualteam.openapigenerator.MediaTypeModel,Boolean) => String,
    getActualRequestBody: casualteam.openapigenerator.RequestBody => casualteam.openapigenerator.RequestBody.Basic,
    getValidationCode: casualteam.openapigenerator.Model => String
 )

import java.nio.charset.Charset

import ModelJson._
import ModelJsonDecode.ops._
import ModelJsonEncode.ops._
import ModelXml._
import ModelXmlDecode.ops._
import ModelXmlEncode.ops._
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server._
import akka.stream.Materializer
import Validation._
import ParameterDecoder._
import ParameterDecoder.ops._

import scala.concurrent.duration.FiniteDuration
import scala.concurrent.ExecutionContext

@modelValidation(parameter: casualteam.openapigenerator.Parameter) = {
    @defining(getValidationCode(parameter.model)){ validation =>
        @if(validation.nonEmpty){
             @if(parameter.required){
                ,
                 validation = @validation
             }else{
                ,
                 validation = _.map(@validation).map(_.map(Some(_))).getOrElse(Right(None))
             }
        }else{}
    }
}

@operationHandling(operation: casualteam.openapigenerator.Operation) = {
    @if(operation.hasInput) {
        @if(operation.requestBody.isDefined){
            val requestBody = requestBodies
                .get(ctx.request.entity.contentType)
                .map(f => f(ctx))
                .getOrElse(notAcceptedContentType)
        } else {
            val requestBody = akka.http.scaladsl.util.FastFuture.successful(())
        }

        val request = requestBody.map{ _requestBody =>
            for {
                @if(operation.requestBody.isDefined){
                    _@getRequestBodyName(operation.requestBody.get) <- _requestBody
                }
                @for((p,l) <- operation.path.flatMap(_.right.toOption).map((_,"Location.Path")) ++ operation.queryParameters.map((_,"Location.Query")) ++ operation.headerParameters.map((_,"Location.Header"))) {
                    _@{p.name} <-  @{p.name}.decodeString[@getModelType(p.model,p.required)](
                    name = "@{p.name}",
                    location = @l
                    @modelValidation(p)
                    )
                }
            } yield {
                @defining(operation.path.flatMap(_.right.toOption) ++ operation.queryParameters ++ operation.headerParameters){ parameters =>
                    Operations.@{getOperationName(operation)}.Request(
                        @if(operation.requestBody.isDefined){
                            @getRequestBodyName(operation.requestBody.get) = _@getRequestBodyName(operation.requestBody.get) @if(parameters.nonEmpty){,}
                        }
                        @for((p,i) <- parameters.zipWithIndex) {
                          @{p.name} = _@{p.name} @if(i < parameters.size -1){,}
                        }
                    )
                }
            }
        }
    } else {
        val request = akka.http.scaladsl.util.FastFuture.successful(Right(Operations.@{getOperationName(operation)}.Request()))
    }

    val mediaTypeNegotiatorResponse = new MediaTypeNegotiator(ctx.request.headers)
    val handler = handlers
      .maxBy{ case (mediaType, _) => mediaTypeNegotiatorResponse.qValueFor(mediaType) }
      ._2
    onSuccess(request.flatMap(handler))(complete(_))

}

object OperationsHandler {

    private val notAcceptedContentType =
        akka.http.scaladsl.util.FastFuture.successful(Left(List(FieldError(
            name = ".",
            location = Location.Body,
            errorType = ErrorType.InvalidValue("Content-Type not accepted")
        ))))


    @for(operation <- operations){
        @defining(for {
                (statusCode,response) <- operation.responses.toList
                baseResponse = getActualResponse(response)
                (contentType,model) <- baseResponse.contentTypeModels
        } yield (statusCode,baseResponse,contentType,model)){ stuff =>

            @for((contentType,i) <- stuff.map(_._3).distinct.zipWithIndex.toList.reverse){
                private def `@{getOperationName(operation)}@{contentType}Handler`(
                    operation: Either[List[FieldError], Operations.@{getOperationName(operation)}.Request] => scala.concurrent.Future[Operations.@{getOperationName(operation)}.Response.`@contentType`],
                    request: Either[List[FieldError], Operations.@{getOperationName(operation)}.Request]
                )(implicit ex: ExecutionContext) =
                    operation(request)
                        .map {
                            @defining(stuff.filter(_._3 == contentType).map(s => (s._1,s._4)).distinct){ s=>
                                @for((statusCode,model) <- s){
                                    @if(statusCode == "default"){
                                        case res: Operations.@{getOperationName(operation)}.Response.`@contentType`.@statusCode =>
                                    } else {
                                        case res: Operations.@{getOperationName(operation)}.Response.`@contentType`.`@statusCode` =>
                                    }
                                        HttpResponse(
                                            status = res.code,
                                            headers = Nil,
                                            entity = res.in.@getMediaTypeModelEncoder(model)
                                        )
                                }
                            }
                        }
            }

            private def @getOperationName(operation)Path(
                operation:Operations.@{getOperationName(operation)}.OperationByType,
                requestTimeout: FiniteDuration,
                requestMaxBytes: Long,
                defaultCharset: Charset
            )(implicit ex: ExecutionContext, materializer: Materializer) = {
                val handlers = List(
                    @for((contentType,i) <- stuff.map(_._3).distinct.zipWithIndex.toList.reverse){
                        (
                            MediaType.parse("@contentType").right.get,
                            `@{getOperationName(operation)}@{contentType}Handler`(operation.`@contentType`, _)
                        )
                        @if(i > 0){,}
                    }
                )

                val requestBodies = Map(
                    @if(operation.requestBody.isDefined){
                        @defining(getActualRequestBody(operation.requestBody.get)){ requestBody =>
                            @for(((contentType,mediaTypeModel),i) <- requestBody.contentTypeModels.toList.zipWithIndex.toList.reverse){
                                (
                                    ContentType.parse("@contentType").right.get,
                                    (ctx:akka.http.scaladsl.server.RequestContext) => {
                                        ctx.request.entity.@getMediaTypeModelDecoder(mediaTypeModel,requestBody.required)
                                        @if(requestBody.required) {
                                            .map(_.map(@getRequestBodyType(requestBody).`@contentType`))
                                        } else {
                                            .map(_.map(_.map(@getRequestBodyType(requestBody).`@contentType`)))
                                        }
                                    }
                                )
                                @if(i > 0){,}
                            }
                        }
                    }
                )

                path (
                    @{operation.path
                        .map(_.fold(
                            resource => "\"" + resource + "\"",
                            pathParam => "Segment"
                        ))
                        .mkString{"/"}
                    }
                ) {
                    @defining(operation.path.flatMap(_.right.toOption)){ pathParams =>
                        @if(pathParams.nonEmpty){
                            case (@{pathParams.map(_.name).mkString(",")}) =>
                        }
                    }

                    @for(parameter <- operation.queryParameters){
                        parameters("@{parameter.name}".?) ( @{parameter.name} =>
                    }
                    @for(parameter <- operation.headerParameters){
                        optionalHeaderValueByName("@{parameter.name}") ( @{parameter.name} =>
                    }

                    @{operation.method.toLowerCase} (extractRequestContext { ctx =>
                        @operationHandling(operation)
                    })

                    @for(_ <- operation.queryParameters){)}
                    @for(_ <- operation.headerParameters){)}
                }
            }
        }
    }

    def getOperationsHandler(
        operations:Operations,
        fallbackResponse: RequestContext => HttpResponse,
        requestTimeout: FiniteDuration,
        requestMaxBytes: Long,
        defaultCharset: Charset
    )(implicit ex:ExecutionContext, materializer: Materializer) = {

        @for(operation <- operations){
            @getOperationName(operation)Path(operations.@getOperationName(operation), requestTimeout, requestMaxBytes, defaultCharset) ~
        }
            pathPrefix("") ( ctx => ctx.complete(fallbackResponse(ctx)) )
    }
}
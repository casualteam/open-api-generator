@(
    operations: List[casualteam.openapigenerator.Operation],
    getOperationName: casualteam.openapigenerator.Operation => String,
    getActualResponse: casualteam.openapigenerator.Response => casualteam.openapigenerator.Response.BaseResponse,
    getModelType: (casualteam.openapigenerator.Model, Boolean) => String,
    getRequestBodyName: casualteam.openapigenerator.RequestBody => String,
    getRequestBodyType: casualteam.openapigenerator.RequestBody => String,
    getMediaTypeModelEncoder: casualteam.openapigenerator.MediaTypeModel => String,
    getMediaTypeModelDecoder: (casualteam.openapigenerator.MediaTypeModel,Boolean) => String,
    getActualRequestBody: casualteam.openapigenerator.RequestBody => casualteam.openapigenerator.RequestBody.Basic
 )

import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.model._
import akka.http.scaladsl.server._
import akka.http.scaladsl._
import ModelJsonEncode.ops._
import ModelXmlEncode.ops._
import ModelJsonDecode.ops._
import ModelXmlDecode.ops._
import ModelJson._
import ModelXml._

@operationHandling(operation: casualteam.openapigenerator.Operation) = {
    @if(operation.hasInput) {
        @if(operation.requestBody.isDefined){
            val @getRequestBodyName(operation.requestBody.get) = ctx.request.entity.getContentType match {
                @defining(getActualRequestBody(operation.requestBody.get)){ requestBody =>
                    @for((contentType,mediaTypeModel) <- requestBody.contentTypeModels.iterator){
                        case m if m == ContentType.parse("@contentType").right.get =>
                            ctx.request.entity.@getMediaTypeModelDecoder(mediaTypeModel,requestBody.required)
                            @if(requestBody.required) {
                                .map(@getRequestBodyType(requestBody).`@contentType`)
                            } else {
                                .map(_.map(@getRequestBodyType(requestBody).`@contentType`))
                            }
                    }
                    @for((contentType,mediaTypeModel) <- requestBody.contentTypeModels.toList.headOption){
                        case _ =>
                            ctx.request.entity.@getMediaTypeModelDecoder(mediaTypeModel,requestBody.required)
                            @if(requestBody.required) {
                                .map(@getRequestBodyType(requestBody).`@contentType`)
                            } else {
                                .map(_.map(@getRequestBodyType(requestBody).`@contentType`))
                            }
                    }
                }
            }
        }

        val request = for {
            @if(operation.requestBody.isDefined){
                _@getRequestBodyName(operation.requestBody.get) <- @getRequestBodyName(operation.requestBody.get)
            }
            @for(p <- operation.path.flatMap(_.right.toOption)) {
              _@{p.name} <- @{p.name}ParameterDecoder.@{p.name}ParameterDecoder(Some(@{p.name}))
            }
            @for(p <- operation.queryParameters ++ operation.headerParameters) {
              _@{p.name} <- @{p.name}ParameterDecoder.@{p.name}ParameterDecoder(@{p.name})
            }
        } yield {
            @defining(operation.path.flatMap(_.right.toOption) ++ operation.queryParameters ++ operation.headerParameters){ parameters =>
                Operations.@getOperationName(operation)Request(
                    @if(operation.requestBody.isDefined){
                        @getRequestBodyName(operation.requestBody.get) = _@getRequestBodyName(operation.requestBody.get) @if(parameters.nonEmpty){,}
                    }
                    @for((p,i) <- parameters.zipWithIndex) {
                      @{p.name} = _@{p.name} @if(i < parameters.size -1){,}
                    }
                )
            }
        }
    } else {
        val request = Right(Operations.@getOperationName(operation)Request())
    }
    onSuccess(operations.@{getOperationName(operation)}(request)){ resp =>
        val mediaTypeNegotiatorResponse = new MediaTypeNegotiator(ctx.request.headers)
        resp match {
            @for((statusCode,response) <- operation.responses.iterator) {
                @if(statusCode == "default"){
                    case _resp:Operations.@getOperationName(operation)Response.default
                } else {
                    case _resp:Operations.@getOperationName(operation)Response.`@statusCode`
                }
                =>
                    @if(getActualResponse(response).contentTypeModels.nonEmpty){
                        val respBody = mediaTypeNegotiatorResponse match {
                            @for((contentType,mediaTypeModel) <- getActualResponse(response).contentTypeModels.iterator){
                                case m if m.isAccepted(MediaType.parse("@contentType").right.get) =>
                                    _resp.in.`@contentType`.@getMediaTypeModelEncoder(mediaTypeModel)
                            }
                            @for((contentType,mediaTypeModel) <- getActualResponse(response).contentTypeModels.toList.headOption){
                                case _ =>
                                    _resp.in.`@contentType`.@getMediaTypeModelEncoder(mediaTypeModel)
                            }
                        }
                    } else {
                        val respBody = Right(HttpEntity.Empty)
                    }
                    respBody.fold(
                        error => failWith(new Exception(s"Fail on request ${ctx.request}, error=$error")),
                        success => complete(HttpResponse(_resp.code,Nil, success))
                    )
            }
        }
    }
}

object OperationHandler {

    def getOperationHandler(
        operations:Operations,
        defaultResponse: RequestContext => HttpResponse
    ) = {

        @for(operation <- operations){
            val @getOperationName(operation)Path =
                path (
                    @{operation.path
                        .map(_.fold(
                            resource => "\"" + resource + "\"",
                            pathParam => "Segment"
                        ))
                        .mkString{"/"}
                    }
                ) {
                    @defining(operation.path.flatMap(_.right.toOption)){ pathParams =>
                        @if(pathParams.nonEmpty){
                            case (@{pathParams.map(_.name).mkString(",")}) =>
                        }
                    }

                    @for(parameter <- operation.queryParameters){
                        parameters("@{parameter.name}".?) ( @{parameter.name} =>
                    }
                    @for(parameter <- operation.headerParameters){
                        optionalHeaderValueByName("@{parameter.name}") ( @{parameter.name} =>
                    }

                    @{operation.method.toLowerCase} (extractRequestContext { ctx =>
                        @operationHandling(operation)
                    })

                    @for(_ <- operation.queryParameters){)}
                    @for(_ <- operation.headerParameters){)}
                }
        }

        @for(operation <- operations){
            @getOperationName(operation)Path ~
        }
            pathPrefix("") ( ctx => ctx.complete(defaultResponse(ctx)) )
    }
}